{"changed":false,"filter":false,"title":"timers.js","tooltip":"/timers.js","value":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Timer = process.binding('timer_wrap').Timer;\nvar L = require('_linklist');\nvar assert = require('assert').ok;\n\n// Timeout values > TIMEOUT_MAX are set to 1.\nvar TIMEOUT_MAX = 2147483647; // 2^31-1\n\nvar debug;\nif (process.env.NODE_DEBUG && /timer/.test(process.env.NODE_DEBUG)) {\n  debug = function() { require('util').error.apply(this, arguments); };\n} else {\n  debug = function() { };\n}\n\n\n// IDLE TIMEOUTS\n//\n// Because often many sockets will have the same idle timeout we will not\n// use one timeout watcher per item. It is too much overhead.  Instead\n// we'll use a single watcher for all sockets with the same timeout value\n// and a linked list. This technique is described in the libev manual:\n// http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#Be_smart_about_timeouts\n\n// Object containing all lists, timers\n// key = time in milliseconds\n// value = list\nvar lists = {};\n\n// the main function - creates lists on demand and the watchers associated\n// with them.\nfunction insert(item, msecs) {\n  item._idleStart = Date.now();\n  item._monotonicStartTime = Timer.now();\n\n  item._idleTimeout = msecs;\n\n  if (msecs < 0) return;\n\n  var list;\n\n  if (lists[msecs]) {\n    list = lists[msecs];\n  } else {\n    list = new Timer();\n    list.start(msecs, 0);\n\n    L.init(list);\n\n    lists[msecs] = list;\n    list.msecs = msecs;\n    list.ontimeout = listOnTimeout;\n  }\n\n  L.append(list, item);\n  assert(!L.isEmpty(list)); // list is not empty\n}\n\nfunction listOnTimeout() {\n  var msecs = this.msecs;\n  var list = this;\n\n  debug('timeout callback ' + msecs);\n\n  var now = Timer.now();\n  debug('now: ' + now);\n\n  var first;\n  while (first = L.peek(list)) {\n    var diff = now - first._monotonicStartTime;\n    if (diff < msecs) {\n      list.start(msecs - diff, 0);\n      debug(msecs + ' list wait because diff is ' + diff);\n      return;\n    } else {\n      L.remove(first);\n      assert(first !== L.peek(list));\n\n      if (!first._onTimeout) continue;\n\n      // v0.4 compatibility: if the timer callback throws and the\n      // domain or uncaughtException handler ignore the exception,\n      // other timers that expire on this tick should still run.\n      //\n      // https://github.com/joyent/node/issues/2631\n      var domain = first.domain;\n      if (domain && domain._disposed) continue;\n      try {\n        if (domain)\n          domain.enter();\n        var threw = true;\n        first._onTimeout();\n        if (domain)\n          domain.exit();\n        threw = false;\n      } finally {\n        if (threw) {\n          // We need to continue processing after domain error handling\n          // is complete, but not by using whatever domain was left over\n          // when the timeout threw its exception.\n          var oldDomain = process.domain;\n          process.domain = null;\n          process.nextTick(function() {\n            list.ontimeout();\n          });\n          process.domain = oldDomain;\n        }\n      }\n    }\n  }\n\n  debug(msecs + ' list empty');\n  assert(L.isEmpty(list));\n  list.close();\n  delete lists[msecs];\n}\n\n\nvar unenroll = exports.unenroll = function(item) {\n  L.remove(item);\n\n  var list = lists[item._idleTimeout];\n  // if empty then stop the watcher\n  debug('unenroll');\n  if (list && L.isEmpty(list)) {\n    debug('unenroll: list empty');\n    list.close();\n    delete lists[item._idleTimeout];\n  }\n  // if active is called later, then we want to make sure not to insert again\n  item._idleTimeout = -1;\n};\n\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  // if this item was already in a list somewhere\n  // then we should unenroll it from that\n  if (item._idleNext) unenroll(item);\n\n  // Ensure that msecs fits into signed int32\n  if (msecs > 0x7fffffff) {\n    msecs = 0x7fffffff;\n  }\n\n  item._idleTimeout = msecs;\n  L.init(item);\n};\n\n\n// call this whenever the item is active (not idle)\n// it will reset its timeout.\nexports.active = function(item) {\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n\n    var list = lists[msecs];\n    if (!list || L.isEmpty(list)) {\n      insert(item, msecs);\n    } else {\n      item._idleStart = Date.now();\n      item._monotonicStartTime = Timer.now();\n      L.append(list, item);\n    }\n  }\n};\n\n\n/*\n * DOM-style timers\n */\n\n\nexports.setTimeout = function(callback, after) {\n  var timer;\n\n  after *= 1; // coalesce to number or NaN\n\n  if (!(after >= 1 && after <= TIMEOUT_MAX)) {\n    after = 1; // schedule on next tick, follows browser behaviour\n  }\n\n  timer = new Timeout(after);\n\n  if (arguments.length <= 2) {\n    timer._onTimeout = callback;\n  } else {\n    /*\n     * Sometimes setTimeout is called with arguments, EG\n     *\n     *   setTimeout(callback, 2000, \"hello\", \"world\")\n     *\n     * If that's the case we need to call the callback with\n     * those args. The overhead of an extra closure is not\n     * desired in the normal case.\n     */\n    var args = Array.prototype.slice.call(arguments, 2);\n    timer._onTimeout = function() {\n      callback.apply(timer, args);\n    }\n  }\n\n  if (process.domain) timer.domain = process.domain;\n\n  exports.active(timer);\n\n  return timer;\n};\n\n\nexports.clearTimeout = function(timer) {\n  if (timer && (timer.ontimeout || timer._onTimeout)) {\n    timer.ontimeout = timer._onTimeout = null;\n    if (timer instanceof Timeout) {\n      timer.close(); // for after === 0\n    } else {\n      exports.unenroll(timer);\n    }\n  }\n};\n\n\nexports.setInterval = function(callback, repeat) {\n  repeat *= 1; // coalesce to number or NaN\n\n  if (!(repeat >= 1 && repeat <= TIMEOUT_MAX)) {\n    repeat = 1; // schedule on next tick, follows browser behaviour\n  }\n\n  var timer = new Timeout(repeat);\n  var args = Array.prototype.slice.call(arguments, 2);\n  timer._onTimeout = wrapper;\n  timer._repeat = true;\n\n  if (process.domain) timer.domain = process.domain;\n  exports.active(timer);\n\n  return timer;\n\n  function wrapper() {\n    callback.apply(this, args);\n    // If callback called clearInterval().\n    if (timer._repeat === false) return;\n    // If timer is unref'd (or was - it's permanently removed from the list.)\n    if (this._handle) {\n      this._handle.start(repeat, 0);\n    } else {\n      timer._idleTimeout = repeat;\n      exports.active(timer);\n    }\n  }\n};\n\n\nexports.clearInterval = function(timer) {\n  if (timer && timer._repeat) {\n    timer._repeat = false;\n    clearTimeout(timer);\n  }\n};\n\n\nvar Timeout = function(after) {\n  this._idleTimeout = after;\n  this._idlePrev = this;\n  this._idleNext = this;\n  this._idleStart = null;\n  this._monotonicStartTime = null;\n  this._onTimeout = null;\n  this._repeat = false;\n};\n\nTimeout.prototype.unref = function() {\n  if (!this._handle) {\n\n    var nowMonotonic = Timer.now();\n    if (!this._idleStart || !this._monotonicStartTime) {\n      this._idleStart = Date.now();\n      this._monotonicStartTime = nowMonotonic;\n    }\n\n    var delay = this._monotonicStartTime + this._idleTimeout - nowMonotonic;\n    if (delay < 0) delay = 0;\n    exports.unenroll(this);\n    this._handle = new Timer();\n    this._handle.ontimeout = this._onTimeout;\n    this._handle.start(delay, 0);\n    this._handle.domain = this.domain;\n    this._handle.unref();\n  } else {\n    this._handle.unref();\n  }\n};\n\nTimeout.prototype.ref = function() {\n  if (this._handle)\n    this._handle.ref();\n};\n\nTimeout.prototype.close = function() {\n  this._onTimeout = null;\n  if (this._handle) {\n    this._handle.ontimeout = null;\n    this._handle.close();\n  } else {\n    exports.unenroll(this);\n  }\n};\n\n\nvar immediateQueue = {};\nL.init(immediateQueue);\n\n\nfunction processImmediate() {\n  var immediate = L.shift(immediateQueue);\n\n  if (L.isEmpty(immediateQueue)) {\n    process._needImmediateCallback = false;\n  }\n\n  if (immediate._onImmediate) {\n    if (immediate.domain) immediate.domain.enter();\n\n    immediate._onImmediate();\n\n    if (immediate.domain) immediate.domain.exit();\n  }\n}\n\n\nexports.setImmediate = function(callback) {\n  var immediate = {}, args;\n\n  L.init(immediate);\n\n  immediate._onImmediate = callback;\n\n  if (arguments.length > 1) {\n    args = Array.prototype.slice.call(arguments, 1);\n\n    immediate._onImmediate = function() {\n      callback.apply(immediate, args);\n    };\n  }\n\n  if (!process._needImmediateCallback) {\n    process._needImmediateCallback = true;\n    process._immediateCallback = processImmediate;\n  }\n\n  if (process.domain) immediate.domain = process.domain;\n\n  L.append(immediateQueue, immediate);\n\n  return immediate;\n};\n\n\nexports.clearImmediate = function(immediate) {\n  if (!immediate) return;\n\n  immediate._onImmediate = undefined;\n\n  L.remove(immediate);\n\n  if (L.isEmpty(immediateQueue)) {\n    process._needImmediateCallback = false;\n  }\n};\n\n\n// Internal APIs that need timeouts should use timers._unrefActive isntead of\n// timers.active as internal timeouts shouldn't hold the loop open\n\nvar unrefList, unrefTimer;\n\n\nfunction unrefTimeout() {\n  var now = Timer.now();\n\n  debug('unrefTimer fired');\n\n  var first;\n  while (first = L.peek(unrefList)) {\n    var diff = now - first._monotonicStartTime;\n\n    if (diff < first._idleTimeout) {\n      diff = first._idleTimeout - diff;\n      unrefTimer.start(diff, 0);\n      unrefTimer.when = now + diff;\n      debug('unrefTimer rescheudling for later');\n      return;\n    }\n\n    L.remove(first);\n\n    var domain = first.domain;\n\n    if (!first._onTimeout) continue;\n    if (domain && domain._disposed) continue;\n\n    try {\n      if (domain) domain.enter();\n      var threw = true;\n      debug('unreftimer firing timeout');\n      first._onTimeout();\n      threw = false;\n      if (domain) domain.exit();\n    } finally {\n      if (threw) process.nextTick(unrefTimeout);\n    }\n  }\n\n  debug('unrefList is empty');\n  unrefTimer.when = -1;\n}\n\n\nexports._unrefActive = function(item) {\n  var msecs = item._idleTimeout;\n  if (!msecs || msecs < 0) return;\n  assert(msecs >= 0);\n\n  L.remove(item);\n\n  if (!unrefList) {\n    debug('unrefList initialized');\n    unrefList = {};\n    L.init(unrefList);\n\n    debug('unrefTimer initialized');\n    unrefTimer = new Timer();\n    unrefTimer.unref();\n    unrefTimer.when = -1;\n    unrefTimer.ontimeout = unrefTimeout;\n  }\n\n  var nowDate = Date.now();\n  var nowMonotonicTimestamp = Timer.now();\n\n  item._idleStart = nowDate;\n  item._monotonicStartTime = nowMonotonicTimestamp;\n\n  if (L.isEmpty(unrefList)) {\n    debug('unrefList empty');\n    L.append(unrefList, item);\n\n    unrefTimer.start(msecs, 0);\n    unrefTimer.when = nowMonotonicTimestamp + msecs;\n    debug('unrefTimer scheduled');\n    return;\n  }\n\n  var when = nowMonotonicTimestamp + msecs;\n\n  debug('unrefList find where we can insert');\n\n  var cur, them;\n\n  for (cur = unrefList._idlePrev; cur != unrefList; cur = cur._idlePrev) {\n    them = cur._monotonicStartTime + cur._idleTimeout;\n\n    if (when < them) {\n      debug('unrefList inserting into middle of list');\n\n      L.append(cur, item);\n\n      if (unrefTimer.when > when) {\n        debug('unrefTimer is scheduled to fire too late, reschedule');\n        unrefTimer.start(msecs, 0);\n        unrefTimer.when = when;\n      }\n\n      return;\n    }\n  }\n\n  debug('unrefList append to end');\n  L.append(unrefList, item);\n};\n","undoManager":{"mark":0,"position":-1,"stack":[]},"ace":{"folds":[],"customSyntax":"javascript","scrolltop":6521,"scrollleft":0,"selection":{"start":{"row":334,"column":25},"end":{"row":334,"column":25},"isBackwards":true},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":464,"state":"start","mode":"ace/mode/javascript"}}}